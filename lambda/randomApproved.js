"use strict";
// lambda/randomApproved.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
// Pull table name from env variable set in CDK
const TABLE_NAME = process.env.ITEMS_TABLE_NAME;
const STATUS_INDEX = "StatusIndex"; // GSI name from your stack
const ddb = new client_dynamodb_1.DynamoDBClient({});
const handler = async (event = {}) => {
    try {
        // Query for APPROVED items in the GSI (you may want to add a filter for latest version)
        const data = await ddb.send(new client_dynamodb_1.QueryCommand({
            TableName: TABLE_NAME,
            IndexName: STATUS_INDEX,
            KeyConditionExpression: "#status = :approved",
            ExpressionAttributeNames: { "#status": "status" },
            ExpressionAttributeValues: { ":approved": { S: "APPROVED" } },
            Limit: 100, // Limit to 100 for perf (you can adjust)
            ScanIndexForward: false, // Get latest items first
        }));
        const items = (data.Items || []).map((item) => ({
            itemId: item.itemId.S,
            version: Number(item.version.N),
            type: item.type.S,
            lang: item.lang.S,
            status: item.status.S,
            createdAt: item.createdAt.S,
            spec: JSON.parse(item.spec.S),
        }));
        if (items.length === 0) {
            return {
                statusCode: 404,
                headers: { "Access-Control-Allow-Origin": "*" },
                body: JSON.stringify({ error: "No approved items found" }),
            };
        }
        // Pick a random one!
        const randomIndex = Math.floor(Math.random() * items.length);
        const selected = items[randomIndex];
        return {
            statusCode: 200,
            headers: { "Access-Control-Allow-Origin": "*" },
            body: JSON.stringify(selected),
        };
    }
    catch (err) {
        console.error("Error fetching approved items:", err);
        return {
            statusCode: 500,
            headers: { "Access-Control-Allow-Origin": "*" },
            body: JSON.stringify({ error: err.message }),
        };
    }
};
exports.handler = handler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZG9tQXBwcm92ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW5kb21BcHByb3ZlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsMkJBQTJCOzs7QUFFM0IsOERBQXdFO0FBRXhFLCtDQUErQztBQUMvQyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFpQixDQUFDO0FBQ2pELE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxDQUFDLDJCQUEyQjtBQUUvRCxNQUFNLEdBQUcsR0FBRyxJQUFJLGdDQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7QUFFNUIsTUFBTSxPQUFPLEdBQUcsS0FBSyxFQUFFLFFBQWEsRUFBRSxFQUFFLEVBQUU7SUFDN0MsSUFBSSxDQUFDO1FBQ0Qsd0ZBQXdGO1FBQ3hGLE1BQU0sSUFBSSxHQUFHLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FDdkIsSUFBSSw4QkFBWSxDQUFDO1lBQ2IsU0FBUyxFQUFFLFVBQVU7WUFDckIsU0FBUyxFQUFFLFlBQVk7WUFDdkIsc0JBQXNCLEVBQUUscUJBQXFCO1lBQzdDLHdCQUF3QixFQUFFLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRTtZQUNqRCx5QkFBeUIsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsRUFBRTtZQUM3RCxLQUFLLEVBQUUsR0FBRyxFQUFFLHlDQUF5QztZQUNyRCxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUseUJBQXlCO1NBQ3JELENBQUMsQ0FDTCxDQUFDO1FBRUYsTUFBTSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM1QyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFFO1lBQ3RCLE9BQU8sRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFFLENBQUM7WUFDaEMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBRTtZQUNsQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFFO1lBQ2xCLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUU7WUFDdEIsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBRTtZQUM1QixJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUUsQ0FBQztTQUNqQyxDQUFDLENBQUMsQ0FBQztRQUVKLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNyQixPQUFPO2dCQUNILFVBQVUsRUFBRSxHQUFHO2dCQUNmLE9BQU8sRUFBRSxFQUFFLDZCQUE2QixFQUFFLEdBQUcsRUFBRTtnQkFDL0MsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUseUJBQXlCLEVBQUUsQ0FBQzthQUM3RCxDQUFDO1FBQ04sQ0FBQztRQUVELHFCQUFxQjtRQUNyQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDN0QsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXBDLE9BQU87WUFDSCxVQUFVLEVBQUUsR0FBRztZQUNmLE9BQU8sRUFBRSxFQUFFLDZCQUE2QixFQUFFLEdBQUcsRUFBRTtZQUMvQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7U0FDakMsQ0FBQztJQUNOLENBQUM7SUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO1FBQ2hCLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0NBQWdDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDckQsT0FBTztZQUNILFVBQVUsRUFBRSxHQUFHO1lBQ2YsT0FBTyxFQUFFLEVBQUUsNkJBQTZCLEVBQUUsR0FBRyxFQUFFO1lBQy9DLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMvQyxDQUFDO0lBQ04sQ0FBQztBQUNMLENBQUMsQ0FBQztBQWxEVyxRQUFBLE9BQU8sV0FrRGxCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gbGFtYmRhL3JhbmRvbUFwcHJvdmVkLnRzXG5cbmltcG9ydCB7IER5bmFtb0RCQ2xpZW50LCBRdWVyeUNvbW1hbmQgfSBmcm9tIFwiQGF3cy1zZGsvY2xpZW50LWR5bmFtb2RiXCI7XG5cbi8vIFB1bGwgdGFibGUgbmFtZSBmcm9tIGVudiB2YXJpYWJsZSBzZXQgaW4gQ0RLXG5jb25zdCBUQUJMRV9OQU1FID0gcHJvY2Vzcy5lbnYuSVRFTVNfVEFCTEVfTkFNRSE7XG5jb25zdCBTVEFUVVNfSU5ERVggPSBcIlN0YXR1c0luZGV4XCI7IC8vIEdTSSBuYW1lIGZyb20geW91ciBzdGFja1xuXG5jb25zdCBkZGIgPSBuZXcgRHluYW1vREJDbGllbnQoe30pO1xuXG5leHBvcnQgY29uc3QgaGFuZGxlciA9IGFzeW5jIChldmVudDogYW55ID0ge30pID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBRdWVyeSBmb3IgQVBQUk9WRUQgaXRlbXMgaW4gdGhlIEdTSSAoeW91IG1heSB3YW50IHRvIGFkZCBhIGZpbHRlciBmb3IgbGF0ZXN0IHZlcnNpb24pXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBkZGIuc2VuZChcbiAgICAgICAgICAgIG5ldyBRdWVyeUNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZTogVEFCTEVfTkFNRSxcbiAgICAgICAgICAgICAgICBJbmRleE5hbWU6IFNUQVRVU19JTkRFWCxcbiAgICAgICAgICAgICAgICBLZXlDb25kaXRpb25FeHByZXNzaW9uOiBcIiNzdGF0dXMgPSA6YXBwcm92ZWRcIixcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHsgXCIjc3RhdHVzXCI6IFwic3RhdHVzXCIgfSxcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7IFwiOmFwcHJvdmVkXCI6IHsgUzogXCJBUFBST1ZFRFwiIH0gfSxcbiAgICAgICAgICAgICAgICBMaW1pdDogMTAwLCAvLyBMaW1pdCB0byAxMDAgZm9yIHBlcmYgKHlvdSBjYW4gYWRqdXN0KVxuICAgICAgICAgICAgICAgIFNjYW5JbmRleEZvcndhcmQ6IGZhbHNlLCAvLyBHZXQgbGF0ZXN0IGl0ZW1zIGZpcnN0XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gKGRhdGEuSXRlbXMgfHwgW10pLm1hcCgoaXRlbSkgPT4gKHtcbiAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5pdGVtSWQuUyEsXG4gICAgICAgICAgICB2ZXJzaW9uOiBOdW1iZXIoaXRlbS52ZXJzaW9uLk4hKSxcbiAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZS5TISxcbiAgICAgICAgICAgIGxhbmc6IGl0ZW0ubGFuZy5TISxcbiAgICAgICAgICAgIHN0YXR1czogaXRlbS5zdGF0dXMuUyEsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IGl0ZW0uY3JlYXRlZEF0LlMhLFxuICAgICAgICAgICAgc3BlYzogSlNPTi5wYXJzZShpdGVtLnNwZWMuUyEpLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIiB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IFwiTm8gYXBwcm92ZWQgaXRlbXMgZm91bmRcIiB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQaWNrIGEgcmFuZG9tIG9uZSFcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpdGVtcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IGl0ZW1zW3JhbmRvbUluZGV4XTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgaGVhZGVyczogeyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBcIipcIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWQpLFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBhcHByb3ZlZCBpdGVtczpcIiwgZXJyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIjogXCIqXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZXJyb3I6IGVyci5tZXNzYWdlIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn07XG4iXX0=